{
  "name": "asyncirc",
  "tagline": "asyncio-based IRC library for Python",
  "body": "Introduction to asyncirc\r\n========================\r\n\r\nAsyncirc is an IRC library based on Python's asyncio. It is designed to\r\nbe easy to use, to provide a nice way of processing IRC events, and to\r\nprovide a Good Enough(TM) abstraction of the IRC protocol. It is *not*\r\ndesigned to be a ready- made bot framework, or to be used without some\r\nknowledge of how IRC works.\r\n\r\nInstallation\r\n------------\r\n\r\nYou can install asyncirc from PyPI, using whatever method you prefer.\r\nThe package name is `asyncio-irc`.\r\n\r\nSignals\r\n-------\r\n\r\nInstead of using callback-style event handler registration, asyncirc\r\nuses *signals*. Signals are provided by the excellent Blinker library.\r\nIt would be advisable to read that page for more information on signals,\r\nbut the tl;dr is::\r\n\r\n    # register a signal handler\r\n    signal(\"signal-name\").connect(signal_handler_function)\r\n\r\n    # send a signal\r\n    signal(\"signal-name\").send(sender, some=\"keyword\", argu=\"ments\")\r\n\r\nAsyncirc defines a lot of signals, which are covered in detail below.\r\n\r\nUsage\r\n=====\r\n\r\nActually using asyncirc is pretty simple. First you need to import it::\r\n\r\n    from asyncirc import irc\r\n\r\nThen you need to create a connection::\r\n\r\n    conn = irc.connect(\"chat.freenode.net\", 6697, use_ssl=True)\r\n\r\nYou'll need to register with the server::\r\n\r\n    conn.register(\"nickname\", \"ident\", \"realname (can contain spaces)\")\r\n\r\nOnce you're registered and connected, you'll want to join some\r\nchannels::\r\n\r\n    @conn.on(\"irc-001\")\r\n    def autojoin_channels(message):\r\n        conn.join([\"#channel1\", \"#channel2\"])\r\n\r\nIf you'd rather not go through all that, you can also use the fluent\r\ninterface::\r\n\r\n    conn = irc.connect(\"chat.freenode.net\", 6697, use_ssl=True) \\\r\n              .register(\"nick\", \"ident\", \"realname\") \\\r\n              .join([\"#channel1\", \"#channel2\"])\r\n\r\nMaybe you want to connect some event handlers::\r\n\r\n    @conn.on(\"join\")\r\n    def on_join(message, user, channel):\r\n        conn.say(channel, \"Hi {}! You're connecting from {}.\".format(user.nick, user.host))\r\n\r\nOnce you're done with that, you need to run the event loop::\r\n\r\n    import asyncio\r\n    asyncio.get_event_loop().run_forever()\r\n\r\nYour shiny new IRC client should now connect and do what you told it to!\r\nCongratulations!\r\n\r\nUsing plugins\r\n-------------\r\n\r\nPlugins let you do new stuff with your connection. To use them, you\r\nimport them before you initially make the connection::\r\n\r\n    from asyncirc import irc\r\n    import asyncirc.plugins.addressed\r\n\r\n    conn = irc.connect(...)\r\n    ...\r\n\r\nPlugins usually send new signals, so you want to handle those::\r\n\r\n    @conn.on(\"addressed\")\r\n    def on_addressed(message, user, target, text):\r\n        # triggers on \"bot_nickname: \" or similar\r\n        bot.say(target, \"{}: You said {} to me!\".format(user.nick, text))\r\n\r\nFundamental types\r\n=================\r\n\r\nThere are a few arguments to your handlers that are instances of\r\nspecific classes. Here are those:\r\n\r\n`user` is usually an instance of the `User` class, which has some\r\nimportant attributes:\r\n\r\n-   `User.nick` contains the nickname of the user\r\n-   `User.user` contains the ident of the user\r\n-   `User.host` contains the host of the user\r\n-   `User.hostmask` contains the full hostmask of the user\r\n\r\nThe `IRCProtocol` object\r\n========================\r\n\r\nYour connection handle (above, named `conn`) can do some useful stuff.\r\nHere's a list of some functions that you might find helpful when writing\r\nyour code.\r\n\r\n-   `IRCProtocol.say(target, message)` will send `message` to either a\r\n    channel or user `target`.\r\n-   `IRCProtocol.join(channel_or_channels)` will join either a single\r\n    channel or a list of channels, depending on what you give it.\r\n-   `IRCProtocol.part(channel_or_channels)` works in a similar way to\r\n    `join`.\r\n-   `IRCProtocol.anything(arguments)` will send the IRC command ANYTHING\r\n    to the server. It's basically a catch-all for any missing method.\r\n\r\nEvents you can handle\r\n=====================\r\n\r\nThere are a lot of things that can happen on IRC. As such, there are a\r\nlot of signals that asyncirc generates. Here's a list of some useful\r\nones, with event handler signatures::\r\n\r\n    @conn.on(\"private-message\")\r\n    def on_private_message(message, user, target, text):\r\n        ...\r\n\r\n    @conn.on(\"public-message\")\r\n    def on_public_message(message, user, target, text):\r\n        ...\r\n\r\n    @conn.on(\"message\")\r\n    def on_any_message(message, user, target, text):\r\n        ...\r\n\r\n    @conn.on(\"private-notice\")\r\n    def on_private_notice(message, user, target, text):\r\n        ...\r\n\r\n    @conn.on(\"public-notice\")\r\n    def on_public_notice(message, user, target, text):\r\n        ...\r\n\r\n    @conn.on(\"notice\")\r\n    def on_any_notice(message, user, target, text):\r\n        ...\r\n\r\n    @conn.on(\"join\")\r\n    def on_join(message, user, channel):\r\n        ...\r\n\r\n    @conn.on(\"part\")\r\n    def on_join(message, user, channel, reason):\r\n        # reason defaults to None if there is no reason\r\n        ...\r\n\r\n    @conn.on(\"quit\")\r\n    def on_quit(message, user, reason):\r\n        ...\r\n\r\n    @conn.on(\"kick\")\r\n    def on_kick(message, kicker, kickee, channel, reason):\r\n        # kicker is a User object\r\n        # kickee is just a nickname\r\n        ...\r\n\r\n    @conn.on(\"nick\")\r\n    def on_nick_change(message, user, new_nick):\r\n        ...\r\n\r\nThese signals are actually sent by the `core` plugin, so that's pretty\r\nneat.\r\n\r\nJust what is that `message` handler argument, anyway?\r\n-----------------------------------------------------\r\n\r\n`message` is a special argument. It contains the parsed commands from\r\nthe IRC server. It has a few useful attributes:\r\n\r\n    ``message.params`` has the arguments of the command\r\n\r\n    ``message.verb`` has the actual IRC verb\r\n\r\n    ``message.sender`` has the hostmask of the sender\r\n\r\n`message` is especially useful when you want to take care of events that\r\ndon't already have a signal attached to them. You can hook into the\r\n`irc` event, or the `irc-verb` event to handle specific verbs. Handlers\r\nfor that will take a single argument `message`.\r\n\r\nPlugins\r\n=======\r\n\r\nThere are a few plugins packaged with asyncirc. These are documented\r\nhere.\r\n\r\n`asyncirc.plugins.nickserv`\r\n---------------------------\r\n\r\nSends events when authentication to NickServ succeeds or fails.\r\nAutomatically tries to regain your nickname when it is not available\r\n(usually doesn't work unless you've authenticated with SASL).\r\n\r\nEvents::\r\n\r\n    @conn.on(\"nickserv-auth-success\")\r\n    def auth_success(message_text):\r\n        # yay! you're authed to nickserv now.\r\n        ...\r\n\r\n    @conn.on(\"nickserv-auth-fail\")\r\n    def auth_fail(message_text):\r\n        # oh no, you had the wrong password!\r\n        # try again or exit!\r\n        ...\r\n\r\n`asyncirc.plugins.sasl`\r\n-----------------------\r\n\r\nHandles IRCv3 SASL authentication. After importing, there's a single\r\nmethod call you need to worry about::\r\n\r\n    asyncirc.plugins.sasl.auth(account_name, password)\r\n\r\nAnd a single event::\r\n\r\n    @conn.on(\"sasl-auth-complete\")\r\n    def sasl_auth_complete(message):\r\n        # yay, you've authenticated with SASL.\r\n        ...\r\n\r\nYou probably don't even have to worry about the event. This plugin talks\r\nto the core plugin so that registration is delayed until SASL\r\nauthentication is done.\r\n\r\n`asyncirc.plugins.cap`\r\n----------------------\r\n\r\nHandles IRCv3 capability negotiation. There's only one method you need\r\nto call to request a capability once you've imported this plugin::\r\n\r\n    asyncirc.plugins.cap.request_capability(\"extended-join\") # or whatever\r\n\r\nThe `caps-acknowledged` event will be fired when the server has\r\nacknowledged our request for capabilities. As soon as we know what set\r\nof capabilities the server supports, the `caps-known` event is fired.\r\n\r\n`asyncirc.plugins.tracking`\r\n---------------------------\r\n\r\nFull state tracking. Some methods::\r\n\r\n    user = asyncirc.plugins.tracking.get_user(hostmask_or_nick)\r\n    chan = asyncirc.plugins.tracking.get_channel(channel_name)\r\n\r\nBased on that, here's some stuff you can do::\r\n\r\n    chan.users     # a list of nicknames in the channel\r\n    user.channels  # a list of channels that the user is in\r\n    user.account   # the user's services account name. works best if you've\r\n                   # requested the extended-join and account-notify capabilities\r\n    chan.mode      # return the channel's mode string\r\n    user.previous_nicks  # return the user's previous nicknames that we know of\r\n\r\nHow it actually works is really complicated. Don't even ask.\r\n\r\n`asyncirc.plugins.addressed`\r\n----------------------------\r\n\r\nIt has an event that fires when someone mentions your bot by name in\r\nIRC::\r\n\r\n    @conn.on(\"addressed\")\r\n    def on_me_addressed(message, user, target, text):\r\n        # text contains the text without the \"your_bot: \" part\r\n        ...\r\n\r\nYou can also register command characters that can be used instead of\r\nyour bot's nickname::\r\n\r\n    asyncirc.plugins.addressed.register_command_character(\";;\")\r\n\r\nQuestions? Issues? Just want to chat?\r\n=====================================\r\n\r\nI'm fwilson on freenode, if you have any questions.\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}